{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createClass\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar net = require(\"net\");\n\nvar selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nvar util = require(\"util\");\n\nvar logger_1 = require(\"./logger\");\n\nvar breakpointHook = require('./breakpointhook.js');\n\nvar logger = new logger_1.Logger('protractor');\n\nvar DebugHelper = /*#__PURE__*/function () {\n  function DebugHelper(browserUnderDebug_) {\n    _classCallCheck(this, DebugHelper);\n\n    this.browserUnderDebug_ = browserUnderDebug_;\n  }\n\n  _createClass(DebugHelper, [{\n    key: \"initBlocking\",\n    value: function initBlocking(debuggerClientPath, onStartFn, opt_debugPort) {\n      this.init_(debuggerClientPath, true, onStartFn, opt_debugPort);\n    }\n  }, {\n    key: \"init\",\n    value: function init(debuggerClientPath, onStartFn, opt_debugPort) {\n      this.init_(debuggerClientPath, false, onStartFn, opt_debugPort);\n    }\n    /**\n     *  1) Set up helper functions for debugger clients to call on (e.g.\n     *     execute code, get autocompletion).\n     *  2) Enter process into debugger mode. (i.e. process._debugProcess).\n     *  3) Invoke the debugger client specified by debuggerClientPath.\n     *\n     * @param {string} debuggerClientPath Absolute path of debugger client to use.\n     * @param {boolean} blockUntilExit Whether to block the flow until process exit or resume\n     *     immediately.\n     * @param {Function} onStartFn Function to call when the debugger starts. The\n     *     function takes a single parameter, which represents whether this is the\n     *     first time that the debugger is called.\n     * @param {number=} opt_debugPort Optional port to use for the debugging\n     *     process.\n     *\n     * @return {Promise} If blockUntilExit, a promise resolved when the debugger process\n     *     exits. Otherwise, resolved when the debugger process is ready to begin.\n     */\n\n  }, {\n    key: \"init_\",\n    value: function init_(debuggerClientPath, blockUntilExit, onStartFn, opt_debugPort) {\n      var _this = this;\n\n      var vm_ = require('vm');\n\n      var flow = selenium_webdriver_1.promise.controlFlow();\n      var context = {\n        require: require\n      };\n\n      global.list = function (locator) {\n        return global.protractor.browser.findElements(locator).then(function (arr) {\n          var found = [];\n\n          for (var i = 0; i < arr.length; ++i) {\n            arr[i].getText().then(function (text) {\n              found.push(text);\n            });\n          }\n\n          return found;\n        });\n      };\n\n      for (var key in global) {\n        context[key] = global[key];\n      }\n\n      var sandbox = vm_.createContext(context);\n      var debuggingDone = selenium_webdriver_1.promise.defer(); // We run one flow.execute block for the debugging session. All\n      // subcommands should be scheduled under this task.\n\n      var executePromise = flow.execute(function () {\n        process['debugPort'] = opt_debugPort || process['debugPort'];\n\n        _this.validatePortAvailability_(process['debugPort']).then(function (firstTime) {\n          onStartFn(firstTime);\n          var args = [process.pid, process['debugPort']];\n\n          if (_this.browserUnderDebug_.debuggerServerPort) {\n            args.push(_this.browserUnderDebug_.debuggerServerPort);\n          }\n\n          var nodedebug = require('child_process').fork(debuggerClientPath, args);\n\n          process.on('exit', function () {\n            nodedebug.kill('SIGTERM');\n          });\n          nodedebug.on('message', function (m) {\n            if (m === 'ready') {\n              breakpointHook();\n\n              if (!blockUntilExit) {\n                debuggingDone.fulfill();\n              }\n            }\n          }).on('exit', function () {\n            // Clear this so that we know it's ok to attach a debugger\n            // again.\n            _this.dbgCodeExecutor = null;\n            debuggingDone.fulfill();\n          });\n        });\n\n        return debuggingDone.promise;\n      }, 'debugging tasks'); // Helper used only by debuggers at './debugger/modes/*.js' to insert code\n      // into the control flow, via debugger 'evaluate' protocol.\n      // In order to achieve this, we maintain a task at the top of the control\n      // flow, so that we can insert frames into it.\n      // To be able to simulate callback/asynchronous code, we poll this object\n      // whenever `breakpointHook` is called.\n\n      this.dbgCodeExecutor = {\n        execPromise_: undefined,\n        execPromiseResult_: undefined,\n        execPromiseError_: undefined,\n        // A dummy repl server to make use of its completion function.\n        replServer_: require('repl').start({\n          input: {\n            on: function on() {},\n            resume: function resume() {}\n          },\n          // dummy readable stream\n          output: {\n            write: function write() {}\n          },\n          useGlobal: true\n        }),\n        // Execute a function, which could yield a value or a promise,\n        // and allow its result to be accessed synchronously\n        execute_: function execute_(execFn_) {\n          var _this2 = this;\n\n          this.execPromiseResult_ = this.execPromiseError_ = undefined;\n          this.execPromise_ = execFn_(); // Note: This needs to be added after setting execPromise to execFn,\n          // or else we cause this.execPromise_ to get stuck in pending mode\n          // at our next breakpoint.\n\n          this.execPromise_.then(function (result) {\n            _this2.execPromiseResult_ = result;\n            breakpointHook();\n          }, function (err) {\n            _this2.execPromiseError_ = err;\n            breakpointHook();\n          });\n        },\n        // Execute a piece of code.\n        // Result is a string representation of the evaluation.\n        execute: function execute(code) {\n          var _this3 = this;\n\n          var execFn_ = function execFn_() {\n            // Run code through vm so that we can maintain a local scope which is\n            // isolated from the rest of the execution.\n            var res;\n\n            try {\n              res = vm_.runInContext(code, sandbox);\n            } catch (e) {\n              res = selenium_webdriver_1.promise.when('Error while evaluating command: ' + e);\n            }\n\n            if (!selenium_webdriver_1.promise.isPromise(res)) {\n              res = selenium_webdriver_1.promise.when(res);\n            }\n\n            return res.then(function (res) {\n              if (res === undefined) {\n                return undefined;\n              } else {\n                // The '' forces res to be expanded into a string instead of just\n                // '[Object]'. Then we remove the extra space caused by the ''\n                // using substring.\n                return util.format.apply(_this3, ['', res]).substring(1);\n              }\n            });\n          };\n\n          this.execute_(execFn_);\n        },\n        // Autocomplete for a line.\n        // Result is a JSON representation of the autocomplete response.\n        complete: function complete(line) {\n          var _this4 = this;\n\n          var execFn_ = function execFn_() {\n            var deferred = selenium_webdriver_1.promise.defer();\n\n            _this4.replServer_.complete(line, function (err, res) {\n              if (err) {\n                deferred.reject(err);\n              } else {\n                deferred.fulfill(JSON.stringify(res));\n              }\n            });\n\n            return deferred.promise;\n          };\n\n          this.execute_(execFn_);\n        },\n        // Code finished executing.\n        resultReady: function resultReady() {\n          return !(this.execPromise_.state_ === 'pending');\n        },\n        // Get asynchronous results synchronously.\n        // This will throw if result is not ready.\n        getResult: function getResult() {\n          if (!this.resultReady()) {\n            throw new Error('Result not ready');\n          }\n\n          if (this.execPromiseError_) {\n            throw this.execPromiseError_;\n          }\n\n          return this.execPromiseResult_;\n        }\n      };\n      return executePromise;\n    }\n    /**\n     * Validates that the port is free to use. This will only validate the first\n     * time it is called. The reason is that on subsequent calls, the port will\n     * already be bound to the debugger, so it will not be available, but that is\n     * okay.\n     *\n     * @returns {Promise<boolean>} A promise that becomes ready when the\n     * validation\n     *     is done. The promise will resolve to a boolean which represents whether\n     *     this is the first time that the debugger is called.\n     */\n\n  }, {\n    key: \"validatePortAvailability_\",\n    value: function validatePortAvailability_(port) {\n      var _this5 = this;\n\n      if (this.debuggerValidated_) {\n        return selenium_webdriver_1.promise.when(false);\n      }\n\n      var doneDeferred = selenium_webdriver_1.promise.defer(); // Resolve doneDeferred if port is available.\n\n      var tester = net.connect({\n        port: port\n      }, function () {\n        doneDeferred.reject('Port ' + port + ' is already in use. Please specify ' + 'another port to debug.');\n      });\n      tester.once('error', function (err) {\n        if (err.code === 'ECONNREFUSED') {\n          tester.once('close', function () {\n            doneDeferred.fulfill(true);\n          }).end();\n        } else {\n          doneDeferred.reject('Unexpected failure testing for port ' + port + ': ' + JSON.stringify(err));\n        }\n      });\n      return doneDeferred.promise.then(function (firstTime) {\n        _this5.debuggerValidated_ = true;\n        return firstTime;\n      }, function (err) {\n        console.error(err);\n        process.exit(1);\n      });\n    }\n  }, {\n    key: \"isAttached\",\n    value: function isAttached() {\n      return !!this.dbgCodeExecutor;\n    }\n  }]);\n\n  return DebugHelper;\n}();\n\nexports.DebugHelper = DebugHelper; //# sourceMappingURL=debugger.js.map","map":null,"metadata":{},"sourceType":"script"}